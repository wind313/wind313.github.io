[{"title":"Bean的生命周期","url":"/2024/11/18/Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","content":"实例化容器找到配置文件中的Bean定义，使用反射创建Bean实例。\n属性赋值注入相关属性，例如@Autowired、@Resource、@Value、构造方法或setter方法注入的各种对象和值。\n初始化Aware接口\n如果Bean实现了BeanNameAware接口，调用setBeanName()方法，将Bean名字传入；\n如果Bean实现了BeanClassLoaderAware接口，调用setBeanClassLoader()方法，传入ClassLoader对象；\n如果Bean实现了BeanFactoryAware接口，调用setBeanFactory()方法，传入BeanFactory对象；\n其他Aware接口。\n\nBeanPostProcessor前置处理如果有和加载这个Bean的容器相关的BeanPostProcessor对象，执行postProcessBeforeInitialization()方法。\nInitializingBean接口如果Bean实现了InitializingBean接口，执行afterPropertiesSet()方法。\ninit-method如果Bean在配置文件中的定义包含init-method属性，执行指定的方法。\nBeanPostProcessor后置处理如果有和加载这个Bean的Spring容器相关的BeanPostProcessor对象，执行postProcessAfterInitialization()方法。\n销毁把 Bean 的销毁方法先记录下来，将来需要销毁 Bean 或者销毁容器的时候，就调用这些方法去释放 Bean 所持有的资源。\n\n如果Bean实现了DisposableBean接口，执行destroy()方法；\n如果Bean在配置文件中定义了destroy-method属性或者使用@PreDestroy注解标记Bean销毁之前执行的方法，执行指定的Bean销毁方法。\n\n","categories":["Spring复习"]},{"title":"类和对象生命周期","url":"/2024/11/17/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","content":"类的生命周期加载通过全限定名，获取字节码文件的字节流，将字节流所代表的静态存储结构，转化为方法区运行时数据结构，并生成一个Class类型的对象，作为方法区中这个类的访问入口。\n由双亲委派机制决定使用哪个类加载器来加载（可以打破双亲委派机制）。\n加载与连接的部分动作是交叉进行的，加载阶段未结束，连接阶段可能就已开始（如字节码文件格式验证）。\n连接\n验证确保字节流包含的信息符合当前JVM要求以及该类不会危害JVM。包括文件格式验证（字节码文件格式检查）、元数据验证（字节码语义检查）、字节码验证（程序语义检查）、符号引用验证（类正确性检查）。\n验证很有必要，但不是必须执行。如果全部代码都已被反复使用和验证，可以使用-Xverify:none参数关闭大部分类验证措施，缩短类加载时间。但Java9开始，验证过程变得更加高效，Java11之后，官方不推荐使用-Xverify:none 参数来关闭验证。\n\n准备为静态变量分配内存并设置初始值（除了被final修饰的变量，因为其在编译时就已经设置）。\nJava7之前静态变量在永久代中分配，Java7（将方法区的实现改为元空间）及之后静态变量与Class对象一起放在堆中。\n\n解析将常量池中符号引用替换为直接引用（得到类或者字段、方法在内存中的指针或者偏移量）。\n针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符 7 类符号引用。\n深入理解Java虚拟机中对符号引用以及直接引用的解释如下：\n\n\n\n初始化执行类的初始化方法（即clinit()方法，编译后自动生成）。\nclinit()是带锁线程安全，在多线程环境下进行类初始化的话可能会引起多个线程阻塞，这种阻塞很难被发现。\n只有以下六种情况，必须对类初始化：\n\nnew（创建该类实例对象）、getstatic（访问该类静态变量，除常量）、putstatic（对该类静态变量赋值）、invokestatic（调用该类类静态方法）；\n使用 java.lang.reflect对该类反射调用时；\n初始化该类的子类时；\n主类（包含main方法的类）；\n使用MethodHandle和VarHandle（轻量级的反射调用）时，必须先使用findStaticVarHandle初始化要调用的类；\nJava8（接口中可以定义defaut修饰的方法）及之后，接口中定义了default修饰的方法时，如果要初始化它的实现类，要先初始化该接口。\n\n使用使用类或者创建对象。\n卸载\n类的所有实例被回收；\n加载该类的类加载器实例被回收；\n类没有在其他任何地方被引用。\n\n满足以上情况，该类会被卸载。\n对象的生命周期类加载检查检查new指令的参数能否在常量池中定位到该类的符号引用，并检查该符号引用对象的类是否被初始化。如果没有，要先加载相应的类。\n分配内存内存分配方式由Java堆是否规整（是否有内存碎片）决定，堆是否规整由垃圾收集器的回收算法决定，标记整理和复制时规整的，标记清除不是规整的。\n两种方式\n指针碰撞（内存规整：Serial、ParNew、Parallel、G1）：\n用过的内存全部整合到一边，没有用过的放在另一边，中间有一个分界指针，需要向着没用过的内存方向将该指针移动对象内存大小位置。\n\n空闲列表（内存不规整：CMS）：\n维护一个列表，该列表中会记录哪些内存块是可用的，在分配的时候，找一块儿足够大的内存块儿来划分给对象实例。\n\n\n并发问题为每一个线程预先在 Eden 区分配一块儿内存（TLAB），JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS+失败重试 进行内存分配。\n初始化零值将分配到的内存空间都初始化为零值（不包括对象头），保证了对象的属性在 Java 代码中可以不赋初始值就直接使用。\n设置对象头对象头由Mark Word（主要部分）和Class Pointer组成。\nMark Word\n对象哈希码：在生命周期中可能改变，尤其在锁状态改变时；\n锁信息：无锁状态（没有锁信息）、偏向锁（包含偏向线程ID）、轻量级锁（包含锁的指针，如自旋锁的记录）、重量级锁（包含指向操作系统的线程调度信息，通常是一个指针）；\nGC信息：对象年龄以及分代信息。\n\nClass Pointerr指向对象的类元数据，包含对象所属类的Class对象引用。Class对象存储了与类相关的结构信息，如字段、方法、父类等。\n执行init方法对虚拟机来说，对象已经产生了，从Java程序来说，创建才开始。执行 new 指令之后会接着执行init方法（构造方法）。\n使用通过引用访问对象的属性和方法，在程序运行过程中被不断使用。\n销毁垃圾回收器会在适当的时候检测并回收不再被引用的对象，释放对象占用的内存空间，完成对象的销毁过程。\n","categories":["JVM复习"]}]