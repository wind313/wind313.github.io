[{"title":"Bean的生命周期","url":"/2024/11/18/Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","content":"实例化容器找到配置文件中的Bean定义，使用反射创建Bean实例。\n属性赋值注入相关属性，例如@Autowired、@Resource、@Value、构造方法或setter方法注入的各种对象和值。\n初始化Aware接口\n如果Bean实现了BeanNameAware接口，调用setBeanName()方法，将Bean名字传入；\n如果Bean实现了BeanClassLoaderAware接口，调用setBeanClassLoader()方法，传入ClassLoader对象；\n如果Bean实现了BeanFactoryAware接口，调用setBeanFactory()方法，传入BeanFactory对象；\n其他Aware接口。\n\nBeanPostProcessor前置处理如果有和加载这个Bean的容器相关的BeanPostProcessor对象，执行postProcessBeforeInitialization()方法。\nInitializingBean接口如果Bean实现了InitializingBean接口，执行afterPropertiesSet()方法。\ninit-method如果Bean在配置文件中的定义包含init-method属性，执行指定的方法。\nBeanPostProcessor后置处理如果有和加载这个Bean的Spring容器相关的BeanPostProcessor对象，执行postProcessAfterInitialization()方法。\n销毁把 Bean 的销毁方法先记录下来，将来需要销毁 Bean 或者销毁容器的时候，就调用这些方法去释放 Bean 所持有的资源。\n\n如果Bean实现了DisposableBean接口，执行destroy()方法；\n如果Bean在配置文件中定义了destroy-method属性或者使用@PreDestroy注解标记Bean销毁之前执行的方法，执行指定的Bean销毁方法。\n\n","categories":["Spring复习"]},{"title":"Redis集群","url":"/2024/11/18/Redis%E9%9B%86%E7%BE%A4/","content":"主从集群主从复制主从复制基于Redis replication（默认使用异步复制），可以通过replicaof（Redis5.0之前是slaveof）命令配置各个节点的主从关系。配置完成后主从节点数据同步会自动进行。\n第一次同步（全量复制）\n从节点（slave）向主节点发送psync命令请求复制，主节点（master）收到psync命令后，使用fullresync命令（全量复制）响应从节点。\npsync包含两个参数：\n\nrunID（redis4.0之后改为replid和replid2）：主服务器runID，第一次同步时值为’?’；\noffset：复制进度，第一次同步时，值为-1；\n\nfullresync返回这两个参数。\n\n主节点执行bgsave命令生成RDB文件（子进程去生成）并发送给从节点，从节点清空当前数据，载入RDB文件。\n这期间的写操作命令写入到replication buffer中。\n\n从节点完成RDB载入后，回复一个确认消息给主节点，主节点将replication buffer里记录的写操作命令发送给从节点，从节点去执行，此时第一次同步就完成了。\n\n\n第一次同步后主节点和从节点会维护一个TCP长连接，主节点通过这个连接将写操作命令发送给从节点，从节点去执行。\n\n当从节点过多时，主节点生成RDB和传输RDB的压力会很大，可以让部分从节点成为其他从节点的主节点去分摊主节点的压力。\n\n增量复制Redis2.8之前如果主从节点在命令同步时网络断开又恢复，从节点就会和主节点需要重新进行一次全量复制。\nRedis2.8开始网络断开恢复后，只把网络断开期间主节点接收到的写操作命令，同步给从节点。\n主节点通过repl_backlog_buffer（复制积压缓冲区，一个环形队列，默认大小1MB，可以自定义）记录从生成RDB文件开始收到的所有写命令，一个主节点只有一个repl_backlog_buffer。\nrepl_backlog_buffer的信息在Replication里，可以通过INFO replication命令查看。\n增量复制过程如下：\n\n从节点恢复网络后，发送psync命令（包含runID和offset）给主节点；\n主节点判断收到的runID和自己的runID是否相等，如果相等，使用continue（增量复制）命令响应从节点；\n主节点将断连期间执行的写命令发给从节点，从节点去执行。\n\n\n以下情况需要全量同步：\n\n从节点缺少的数据不在repl_backlog_buffer中；\n从节点宕机或重启，runID和offset丢失；\n主节点宕机，新选出来的主节点的runID和offset会发生变化。\n\nRedis4.0之后主从切换后仍然可能使用增量复制。\n使用replid和replid2代替runid：\n\n主节点：replid就是自己的id。主从切换之前，replid2为空；主从切换之后，新主节点的replid2是旧主节点（自己之前的主节点）的replid。\n从节点：replid是自己当前的主节点的replid。replid2是旧主节点的replid。\n\n还有两个字段：\n\nmaster_repl_offset：当前的复制偏移量；\nsecond_replid_offset：主从切换前，值为-1，主从切换后，新的主节点的second_replid_offset是旧主节点的复制偏移量。\n\n通过replid和replid2判断主从切换之后，新的主节点和从节点曾经是否属于同一个主库。如果属于同一个主库，可能进行增量复制。\n新主节点同步进度必须比从节点快，并且进度差异不能超过repl_backlog_buffer大小，否则进行全量复制。\nRDB会记录主从复制相关信息（比如replid），用于解决从节点重启后需要全量复制的问题。\n从节点可能读到过期数据\nRedis3.2之前，客户端读从库不会判断数据是否过期，可能返回过期数据。Redis3.2之后，客户端读从库会优先判断数据是否过期，如果过期，从库不会删除，但会返回空数据，避免返回空数据。\n使用EXPIRE和PEXPIRE设置过期时间（执行该命令往后TTL时间过期）时，如果从节点执行命令因为网络等原因延迟，客户端可能读到过期数据。可以使用EXPIREAT和PEXPIREAT（设置过期的时间戳），但主从节点时钟需保持一致。\n\n哨兵哨兵（sentinel，稳定版在Redis2.8之后发布）是Redis的一种特殊运行模式，也是一个节点，不提供读写服务，默认端口26379。\n运行哨兵通过以下命令让Redis以哨兵模式运行：\nredis-sentinel /path/to/sentinel.conf\n或\nredis-server /path/to/sentinel.conf --sentinel\n建议启动三个以上并且奇数个哨兵协作运行，可以增强容错性（避免网络波动等因素导致的误判）和可用性（一个哨兵失效，其他依然可用）。\n哨兵功能\n监控：监控所有节点（包括自己）状态是否正常；\n故障转移：主节点故障时，自动将一个从节点升级为主节点；\n通知：通知从节点新的主节点连接信息，让它们执行replicaof成为新的主节点的从节点；\n配置提供：客户端连接哨兵，如果故障转移，哨兵会通知新的主节点信息给客户端。\n\n哨兵集群组成哨兵节点之间通过Redis的发布订阅机制互相发现。主从集群中，主节点有一个_sentinel_:hello频道，不同哨兵通过该频道实现互相发现和互相通信。\n哨兵每10秒会向主节点发送INFO命令获取所有从节点列表，根据列表中的连接信息，和每个从节点建立连接并监控从节点。\n\n检测节点下线哨兵每隔1秒会给其他所有节点发送ping命令，其他节点会响应（pong、loading或masterdown），如果没有在规定时间内响应，哨兵就会标记该节点为主观下线。\n哨兵如果认为主观下线的是从节点，不会做什么。如果是主节点，哨兵向其他哨兵发起命令，其他根据自身和该主节点的网络状况，做出赞成或拒绝的响应。当赞同数量达到哨兵配置文件中的quorum配置项设定的值（建议为哨兵个数&#x2F;2+1）后，主节点才会被判定为客观下线。\n\n然后，哨兵集群会选举（Raft算法）出一个leader进行故障转移。\n选举哨兵集群的leader判断主节点下线的哨兵为候选者，候选者向其他哨兵发送命令表明希望成为leader，其他哨兵进行投票。每个哨兵只有一次投票机会，候选者可以把票投给自己，非候选者只能投给其他哨兵。\n候选者拿到半数以上的票并且票数大于等于哨兵配置文件中的quorum值才能成为leader。\n\n故障转移过程1.选举新主节点；\n\n把已下线的从节点和网络不好的从节点过滤掉。\n如果在down-after-milliseconds（主从最大连接超时时间）毫秒内，主从节点没有通过网络联系上，就可以认为主从节点断连了。如果断连次数超过10次，就认为该节点网络不好。\n\n先根据从节点优先级排序。\n可以修改配置文件中的replica-priority（Redis5.0之前叫slave-priority）手动配置slave的优先级。默认100，越小越靠前，但0表示没有选举资格。没有最高的再进行下一步排序。\n\n再根据复制进度排序。\n数据越完整，即与旧主节点数据越接近的越靠前。没有最高的再进行下一步排序。\n\n最后根据runID排序，越小越靠前。\n\n\n2.将从节点指向新主节点；\n通过向从节点发送slaveof命令，让旧主节点的所有从节点指向新主节点。\n3.通知客户端；\n每个哨兵提供发布订阅机制，客户端可以从客户端订阅消息。主从切换完成后，哨兵会向+switch-master频道发布新主节点的IP地址和端口消息。通过订阅发布机制，客户端不仅可以在主从切换后得到新主节点的连接信息，还可以监控主从节点切换过程中发生的重要事件，有助于了解切换速度。\n4.将旧主节点变为从节点。\n继续监视旧主节点，当旧主节点重新上线时，哨兵集群向它发送slaveof命令，让他成为新主节点的从节点。\n\n切片集群Redis3.0推出官方切片集群解决方案Redis Cluster。\nRedis Cluster优势\n支持动态扩容和缩容\n具备主从复制、故障转移（内置哨兵机制，不用单独部署哨兵集群）等开箱即用功能。\n\nRedis Cluster架构至少3个主节点和三个从节点，即每个主节点有一个从节点。\nRedis Cluster是去中心化的（每个节点使用Gossip协议通信），key找的是hash槽不是节点，一个主节点故障，不会影响其他主节点。\nRedis Cluster分片采用hash槽（hash slot）分区，每一个键值对属于一个hash槽。\n一个Redis Cluster有16384个hash槽，只需要对key计算CRC-16（XMODEM）校验码（16bit的值），并对校验码取模16384，得到的即是key对应的hash槽。\nhash槽分区优点解耦数据与节点之间的关系，提升集群的横向扩展性和容错性。\nhash槽与节点之间的映射hash槽与节点之间的映射有两种方案：\n\n平均分配：创建并初始化Redis Cluster时，会自动将hash槽平均分配到集群节点上。\n\n手动分配：可以使用cluster meet命令手动建立节点间连接建立集群，再使用cluster addslots命令指定每个节点hash槽个数。\n在手动分配哈希槽时，需要把 16384 个槽都分配完，否则 Redis 集群无法正常工作。\n\n\n在任意主节点上执行cluster slots命令可以查看hash槽与节点映射关系。\n移除某个主节点之前，要将该节点hash槽移动到其他节点上，才可以删除，否则报错。\n客户端定位目标节点客户端连接到任意主节点就可以访问Redis Cluster的数据，客户端发送请求时，根据key找到对应hash槽，再查询hash槽和节点的映射关系就可以找到目标节点。如果hash槽是当前节点负责，直接返回结果；否则（当Redis Cluster重新分配hash槽比如扩容缩容时，可能导致客户端缓存的hash槽分配信息有误）返回-MOVED重定向错误，告知客户端该hash槽是哪个节点负责，客户端向目标节点发送请求并更新缓存的hash槽分配信息。\n\n重定向机制重定向机制可以保证Redis Cluster在扩容和缩容期间能正常对外提供服务，分为ASK重定向（临时重定向）和MOVED重定向（永久重定向）。\n\n如果请求的key对应的hash槽还在当前节点，或者在迁移过程中但key还未迁移走，直接响应；\n如果请求的key对应的hash槽在迁移过程中，且key已经迁移走；\n返回ASK（包含新节点信息）；\n客户端收到ASK，会临时重定向（一次性），即向新节点发送一条ASKING命令，下一次需要重新提前发送ASKING命令；\n如果当前请求的key还在导入中但未完全导入，新节点收到ASKING命令后可能会返回TRYAGAIN（重试错误）；\n客户端发送真正需要请求的命令；\nASK重定向不会更新客户端缓存的hash槽分配信息。\n\n\n如果请求的key对应的hash槽迁移完成，返回-MOVED，客户端向新节点请求并更新缓存的hash槽分配信息。\n\n\n节点间的通信Redis Cluster中的各个节点基于Gossip协议进行通信，每个节点维护一份集群的状态信息。\nRedis Cluster的节点之间会互相发送多种Gossip信息：\n\nMEET：在集群的某个节点上执行CLUSTER MEET ip port命令，可以向指定节点发送一个MEET信息，将其添加进集群中成为新节点。\nPING&#x2F;PONG：集群中的节点都会定时向其他节点发送PING，交换各个节点状态信息，检查各个节点状态，包括在线状态、疑似下线状态（PFAIL）和已下线状态（FAIL）；\nFAIL：集群中的A节点发现B节点疑似下线，并且在下线报告的有效期限内集群中半数以上节点将B节点标记为疑似下线，A节点就会向集群广播一条FAIL消息，通知其他节点将B标记为已下线。\n……\n\n源码redis&#x2F;src&#x2F;cluster.h at 7.0 · redis&#x2F;redis中定义了所有消息类型和消息结构。\n","categories":["Redis复习"]},{"title":"类和对象生命周期","url":"/2024/11/17/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","content":"类的生命周期加载通过全限定名，获取字节码文件的字节流，将字节流所代表的静态存储结构，转化为方法区运行时数据结构，并生成一个Class类型的对象，作为方法区中这个类的访问入口。\n由双亲委派机制决定使用哪个类加载器来加载（可以打破双亲委派机制）。\n加载与连接的部分动作是交叉进行的，加载阶段未结束，连接阶段可能就已开始（如字节码文件格式验证）。\n连接\n验证确保字节流包含的信息符合当前JVM要求以及该类不会危害JVM。包括文件格式验证（字节码文件格式检查）、元数据验证（字节码语义检查）、字节码验证（程序语义检查）、符号引用验证（类正确性检查）。\n验证很有必要，但不是必须执行。如果全部代码都已被反复使用和验证，可以使用-Xverify:none参数关闭大部分类验证措施，缩短类加载时间。但Java9开始，验证过程变得更加高效，Java11之后，官方不推荐使用-Xverify:none 参数来关闭验证。\n\n准备为静态变量分配内存并设置初始值（除了被final修饰的变量，因为其在编译时就已经设置）。\nJava7之前静态变量在永久代中分配，Java7（将方法区的实现改为元空间）及之后静态变量与Class对象一起放在堆中。\n\n解析将常量池中符号引用替换为直接引用（得到类或者字段、方法在内存中的指针或者偏移量）。\n针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符 7 类符号引用。\n深入理解Java虚拟机中对符号引用以及直接引用的解释如下：\n\n\n\n初始化执行类的初始化方法（即clinit()方法，编译后自动生成）。\nclinit()是带锁线程安全，在多线程环境下进行类初始化的话可能会引起多个线程阻塞，这种阻塞很难被发现。\n只有以下六种情况，必须对类初始化：\n\nnew（创建该类实例对象）、getstatic（访问该类静态变量，除常量）、putstatic（对该类静态变量赋值）、invokestatic（调用该类类静态方法）；\n使用 java.lang.reflect对该类反射调用时；\n初始化该类的子类时；\n主类（包含main方法的类）；\n使用MethodHandle和VarHandle（轻量级的反射调用）时，必须先使用findStaticVarHandle初始化要调用的类；\nJava8（接口中可以定义defaut修饰的方法）及之后，接口中定义了default修饰的方法时，如果要初始化它的实现类，要先初始化该接口。\n\n使用使用类或者创建对象。\n卸载\n类的所有实例被回收；\n加载该类的类加载器实例被回收；\n类没有在其他任何地方被引用。\n\n满足以上情况，该类会被卸载。\n对象的生命周期类加载检查检查new指令的参数能否在常量池中定位到该类的符号引用，并检查该符号引用对象的类是否被初始化。如果没有，要先加载相应的类。\n分配内存内存分配方式由Java堆是否规整（是否有内存碎片）决定，堆是否规整由垃圾收集器的回收算法决定，标记整理和复制时规整的，标记清除不是规整的。\n两种方式\n指针碰撞（内存规整：Serial、ParNew、Parallel、G1）：\n用过的内存全部整合到一边，没有用过的放在另一边，中间有一个分界指针，需要向着没用过的内存方向将该指针移动对象内存大小位置。\n\n空闲列表（内存不规整：CMS）：\n维护一个列表，该列表中会记录哪些内存块是可用的，在分配的时候，找一块儿足够大的内存块儿来划分给对象实例。\n\n\n并发问题为每一个线程预先在 Eden 区分配一块儿内存（TLAB），JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS+失败重试 进行内存分配。\n初始化零值将分配到的内存空间都初始化为零值（不包括对象头），保证了对象的属性在 Java 代码中可以不赋初始值就直接使用。\n设置对象头对象头由Mark Word（主要部分）和Class Pointer组成。\nMark Word\n对象哈希码：在生命周期中可能改变，尤其在锁状态改变时；\n锁信息：无锁状态（没有锁信息）、偏向锁（包含偏向线程ID）、轻量级锁（包含锁的指针，如自旋锁的记录）、重量级锁（包含指向操作系统的线程调度信息，通常是一个指针）；\nGC信息：对象年龄以及分代信息。\n\nClass Pointerr指向对象的类元数据，包含对象所属类的Class对象引用。Class对象存储了与类相关的结构信息，如字段、方法、父类等。\n执行init方法对虚拟机来说，对象已经产生了，从Java程序来说，创建才开始。执行 new 指令之后会接着执行init方法（构造方法）。\n使用通过引用访问对象的属性和方法，在程序运行过程中被不断使用。\n销毁垃圾回收器会在适当的时候检测并回收不再被引用的对象，释放对象占用的内存空间，完成对象的销毁过程。\n","categories":["JVM复习"]}]